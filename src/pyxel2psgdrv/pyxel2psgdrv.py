# -*- coding: utf-8 -*-
# ================================================================
# pyxel2psgdrv.py
#
# licence:MIT Licence
# copyright-holders:Hitoshi Inoue(brapunch2000)
# ================================================================
#
# 概要：
# Pyxel形式のサウンドファイルをmsx-PSGSoundDriver形式のASMソース形式に変換する。
# msx-PSGSoundDriver : https://github.com/aburi6800/msx-PSGSoundDriver/tree/master
# (以下、msg-PSGSoundDriverをSOUNDドライバと記載)
#
# 仕様：
# Pyxel形式のサウンドファイル（例：sound.pyxres）をZIPファイルとして展開し
# musiX, soundXX（Xは0オリジンの連番）のファイルにする
# その後、以下の処理を行う
#
# ・SOUNDファイルをASM形式に変換する
#
# (SOUNDファイル1行目)
# 1行目を2桁ずつの16進数文字列に区切る。区切った個数が音の数になる。
# その16進文字列を数値にして、0x0Cを加算する。
# 加算するとSOUNDドライバで規定されているトーンの数値になる
# 
# (SOUNDファイル2行目)
# 文字列を音の数ぶん1桁ずつに分割する。
# '3'であればその1音はノイズとして判定し、ノイズトーンをASMに出力する。
# ノイズトーン値の算式:
#   31-(int(トーンの数値x0.33))
# ノイズトーンの場合は、ミキシングの値は"00B"(Tone On/Noise On)として出力する。
# '3'ではない場合、直前の音がノイズであればミキシングのノイズ値をOFFにする(10B)
#
# (SOUNDファイル3行目)
# 文字列を音の数ぶん1桁ずつに分割する。
# この数値に2を掛けた数値が音1個の音量となる。
#
# (SOUNDファイル4行目)
# この行は無視する
#
# (SOUNDファイル5行目)
# SPEED値。この値を2で割った値が音1個あたりの音長(n/60秒)となる
# 1未満の場合は1とする
#
# ・MUSICファイルをASM形式に変換する
# 
# (MUSICファイル1行目:ch1）
# 1行目を2桁ずつの数値に分割する
# 分割した数値はsoundXファイルのXに該当する
# 
# (MUSICファイル2行目:ch2）
# 1行目を2桁ずつの数値に分割する
# 分割した数値はsoundXファイルのXに該当する
# 
# (MUSICファイル3行目:ch3）
# 1行目を2桁ずつの数値に分割する
# 分割した数値はsoundXファイルのXに該当する
# 
#

import os
import sys
import traceback
import shutil
import argparse
import glob

def main():

    _inFilePath = ""
    _outPath = ""

    _argparser = argparse.ArgumentParser(description="Convert .asm data from Pyxel music data.(.pyxres file).")
    _argparser.add_argument("--resource", "-res", help=".pyxres file path.")
    _argparser.add_argument("--outpath", "-o", help="output directory path.", default="")
    _argparser.add_argument("--force", "-f", action="store_const", const="", help="Ignore output even if the file exists.")
    _args = _argparser.parse_args()

    # 入力ファイルのフルパスを設定
    _inFilePath = filePathUtil(_args.resource)

    # 出力ファイルのフルパスを設定
    _outPath = ""
    if _args.outpath != "":
        _outPath = filePathUtil(_args.outpath)

    # 引数チェック
    try:
        # 入力ファイルの拡張子は.pyxres以外はエラー
        if os.path.splitext(_args.resource)[1] != ".pyxres":
            raise Exception("File extension is not '.pyxres' " + _inFilePath)

        # 入力ファイルの存在チェック
        if os.path.exists(_inFilePath) == False:
            raise Exception("File not found " + _inFilePath)

        # 出力パスが省略された場合は入力ファイルのファイルパスを出力先ディレクトリとする
        if _outPath == "":
            _outPath = os.path.dirname(_inFilePath)

        # 出力パスが存在しない場合はエラーとする
        if os.path.exists(_outPath) == False:
            raise Exception("Output directory not found " + _outPath)

        # 存在チェック
        # オプション --force(-f)が設定されている場合はエラーとしない
        if os.path.exists(_outPath) and _args.force == None:
            raise FileExistsError("Specified file already exists " + _outPath)

    except Exception as e:
        print(format(e))
        sys.exit()

    # Pyxelリソースファイル(.pyxres)をZIPファイルにして展開する
    unzip(_inFilePath, _outPath)
    
    # soundファイルを読み込み
    # soundXX.asmファイルを生成する
    _soundFiles = glob.glob(_outPath + os.sep + "pyxel_resource" + os.sep + "sound*")
    makeSoundFiles(_soundFiles)

    # musicファイルを読み込み
    # musicX.asmファイルを生成する
    # ※musicX.asmファイルをSOUNDドライバにincludeする
    _musicFiles = glob.glob(_outPath + os.sep + "pyxel_resource" + os.sep + "music*")
    makeMusicFiles(_musicFiles)

    # 作成されたASMファイルのパスを表示する
    print("Conversion success.")
    _asmFiles = glob.glob(_outPath + os.sep + "pyxel_resource" + os.sep + "*asm")
    print("The following ASM files were generated by converting the Pyxel sound data.")
    for _x in _asmFiles:
        print("%s" % (_x))

def makeSoundFiles(_soundFiles):
    '''
    soundXX ファイルを読み込み、SOUNDドライバの形式にして
    soundXX.asmファイルを作成する
    作成先のディレクトリはsoundXXと同じディレクトリとする
    '''

    for _path in _soundFiles:

        _outFile = _path + ".asm"

        _rec = []

        with open(_path, "r") as fd:
            # 行情報を読み込む(行末の改行は含まない)
            for _line in fd:
                _rec.append(_line.rstrip(os.linesep))

        _note = []
        _volume = []
        _speed = 0

        for _idx in range(5):
            if _idx == 0:
                # 1行目の処理
                _note = parseSoundLine1(_rec[_idx])
            elif _idx == 1:
                # 2行目の処理
                # とりあえず、2行目は無視
                pass
            elif _idx == 2:
                # 3行目の処理
                _volume = parseSoundLine3(_rec[_idx])
            elif _idx == 3:
                # 4行目の処理
                # とりあえず、4行目は無視
                pass
            elif _idx == 4:
                # 5行目の処理
                _speed = int(_rec[_idx])
                _speed = int(_speed * 0.5)
                if _speed < 0:
                    _speed = 1

        # ASMファイルを出力する
        _basename = os.path.basename(_outFile)
        _soundlabel = os.path.splitext(_basename)[0].upper()

        with open(_outFile, "w") as fd:

            # LABELを出力
            print("; Pyxel SOUND DATA:%s " % (_soundlabel), file=fd)

            # _noteの個数分、以下を繰り返す
            #
            # defb ボリューム(_volume)
            # defb ノート番号(_note)
            # defb 音長(_speed)
            # 

            for _idx in range(len(_note)):
                print("defb %s" % (_volume[_idx]), file=fd)
                print("defb $%s" % (_note[_idx]), file=fd)
                print("defb %d" % (_speed), file=fd)
                
def parseSoundLine1(_buf):
    '''
    soundXX ファイル1行目のパース
    文字列を2桁ずつに分割する。
    2桁の16進文字列を数値化し、その数値に0x0C(12)を加算する
    加算した結果を再度16進文字列2桁にして配列に詰め返却する
    '''
    _cutBuf = _buf
    _hexArr = []
    while True:
        if len(_cutBuf) <= 0:
            break
        _hexArr.append(_cutBuf[:2])
        _cutBuf = _cutBuf[2:]

    for _idx in range(len(_hexArr)):
        # 数値に0x0Cを加算してその値を再度16進文字列に変換し
        # 格納しなおす
        _hexStr = "0x" + _hexArr[_idx]
        _hexVal = int(_hexStr, 0)
        _hexVal += 12
        _hexArr[_idx] = hex(_hexVal)[2:]

    return _hexArr

def parseSoundLine3(_buf):
    '''
    soundXX ファイル3行目のパース
    文字列を1桁ずつに分割する。
    1桁の10進文字列を数値化し、その数値を2倍して200を加算する
    算出した結果を再度10進文字列にして配列に詰め返却する
    '''
    _cutBuf = _buf
    _decArr = []
    while True:
        if len(_cutBuf) <= 0:
            break
        _decArr.append(_cutBuf[:1])
        _cutBuf = _cutBuf[1:]
    
    for _idx in range(len(_decArr)):
        _decStr = _decArr[_idx]
        _decVal = int(_decStr, 0)
        _decVal = _decVal * 2 + 200
        _decArr[_idx] = str(_decVal)

    return _decArr

def makeMusicFiles(_musicFiles):
    '''
    musicX ファイルを読み込み、SOUNDドライバの形式にして
    musicX.asmファイルを作成する
    作成先のディレクトリはmusicXと同じディレクトリとする
    '''

    for _path in _musicFiles:

        _outFile = _path + ".asm"
        _musicFilePath = os.path.dirname(_path)

        _rec = []

        with open(_path, "r") as fd:
            # 行情報を読み込む(行末の改行は含まない)
            for _line in fd:
                _rec.append(_line.rstrip(os.linesep))

        _ch1 = []
        _ch2 = []
        _ch3 = []

        # 先頭3行だけしか読み込まない
        # Pyxelは4ch出力するがMSXは3chしかないため
        # 4ch目はスキップする
        for _idx in range(3):
            if _idx == 0:
                # 1行目の処理
                _ch1 = parseMusicLine(_rec[_idx], _musicFilePath)
            elif _idx == 1:
                # 2行目の処理
                _ch2 = parseMusicLine(_rec[_idx], _musicFilePath)
            elif _idx == 2:
                # 3行目の処理
                _ch3 = parseMusicLine(_rec[_idx], _musicFilePath)

        # 読み込んだch情報をSOUNDドライバの形式に加工する
        _basename = os.path.basename(_outFile)
        _musiclabel = os.path.splitext(_basename)[0].upper()

        _ch1_label = "%s_TRK1" % (_musiclabel)
        _ch2_label = "%s_TRK2" % (_musiclabel)
        _ch3_label = "%s_TRK3" % (_musiclabel)

        if len(_ch1) == 0:
            _ch1_label = "0"
        if len(_ch2) == 0:
            _ch2_label = "0"
        if len(_ch3) == 0:
            _ch3_label = "0"

        with open(_outFile, "w") as fd:

            # LABELを出力
            print("; Pyxel MUSIC DATA:%s " % (_musiclabel), file=fd)
            print("%s:" % (_musiclabel), file=fd)

            # SOUNDドライバのプライオリティは0にしておく
            print("defb 0", file=fd)

            print("defw %s" % (_ch1_label), file=fd)
            print("defw %s" % (_ch2_label), file=fd)
            print("defw %s" % (_ch3_label), file=fd)
            print("", file=fd)

            # ch1の出力
            if len(_ch1) > 0:
                print("%s:" % (_ch1_label), file=fd)
                print("defb 217, 10B ; Mixing Tone/Noise off", file=fd)
                for _idx in range(len(_ch1)):
                    print("%s" % (_ch1[_idx]), file=fd)
                print("defb 254      ; End of Data", file=fd)

            # ch2の出力
            if len(_ch2) > 0:
                print("%s:" % (_ch2_label), file=fd)
                print("defb 217, 10B ; Mixing Tone/Noise off", file=fd)
                for _idx in range(len(_ch2)):
                    print("%s" % (_ch2[_idx]), file=fd)
                print("defb 254      ; End of Data", file=fd)

            # ch3の出力
            if len(_ch3) > 0:
                print("%s:" % (_ch2_label), file=fd)
                print("defb 217, 10B ; Mixing Tone/Noise off", file=fd)
                for _idx in range(len(_ch2)):
                    print("%s" % (_ch2[_idx]), file=fd)
                print("defb 254      ; End of Data", file=fd)

def parseMusicLine(_buf, _musicFilePath):
    '''
    musicX ファイル1行目のパース
    文字列を2桁ずつに分割する。
    すべて分割したら個々の2桁の文字列をsoundXX.asmのファイル名のXX部分に置き換え
    soundXX.asmファイルを連結していく。
    '''

    _cutBuf = _buf
    _numArr = []

    if _buf == "none":
        # CHのSOUND情報が存在しなければ空のリストを返却して終了する
        return []

    while True:
        if len(_cutBuf) <= 0:
            break
        _numArr.append(_cutBuf[:2])
        _cutBuf = _cutBuf[2:]

    _ch_rec = []

    for _idx in range(len(_numArr)):
        with open(_musicFilePath + os.sep + "sound%s.asm" % (_numArr[_idx]), "r") as fd:
            for _line in fd:
                _ch_rec.append(_line.rstrip(os.linesep))

    return _ch_rec


def filePathUtil(path:str) -> str:
    '''
    ファイルパスユーティリティ\n
    引数のパスにディレクトリを含んでいない場合、カレントディレクトリを付与したフルパスを生成して返却します。\n
    \n
    Parameters\n
    ----------\n
    path : str\n
        ファイルパス
    \n
    Returns\n
    -------\n
    str\n
        フルパスに編集後の文字列\n
    ''' 
    # 入力ファイルのフルパスからファイル名を取得
    _filename = os.path.basename(path)
        
    # 入力ファイルのフルパスからファイルパスを取得 
    _filepath = os.path.dirname(path)
    if _filepath == "" or _filepath == None:
        # ファイルパスが取得できなかった場合（ファイル名のみ指定された場合）は現在のパスを設定
        _filepath = os.path.dirname(__file__)

    return _filepath + os.sep + _filename

def unzip(_inFilePath:str, _outPath:str):

    try:
        shutil.rmtree(_outPath + os.sep + "pyxel_resource")
    except OSError:
        # 既に削除されていたら例外が発生するがスルーする
        pass

    # ZIPを展開
    shutil.unpack_archive(_inFilePath, _outPath, format="zip")

if __name__ == "__main__":
    main()
